This repository contains python modules and scripts to run the experiments in the preprint ``Bringing statistics to storylines: rare event sampling for sudden, transient extreme events'' by Justin Finkel and Paul A. O'Gorman. A brief overview of the file/directory organization follows.

# Structure of directories and classes 

The top-level folder, `TEAMS_L96`, contains abstract class definitions for managing ensembles of trajectories of dynamical systems, whereas the subfolder `TEAMS_L96/examples/lorenz96` instantiates those classes for the Lorenz-96 model. In principle, a user can add further examples by modifying the Lorenz-96-specific code and putting it into another folder, e.g., `TEAMS_L96/examples/mymodel`. The general classes are as follows:

1. `ensemble.py` defines two abstract classes: 
    - `EnsembleMember` represents a single, unbroken forward simulation. It has abstract methods for running dynamics forward (which must be instantiated by each system separately; for Lorenz-96, it is a simple Euler-Maruyama timestep, but for complex models one could call Fortran code through a subprocess or `f2py`). It also contains metadata, such as directories for saving output and `warmstart_info`, which contains initial conditions and perturbations needed for the integration. There is also an abstract method for loading the history of an ensemble member into memory, which is useful when we have thousands of integrations that would be unwieldy or impossible to store at once. 
    - `Ensemble` represents a branching tree of `EnsembleMember`s evolving according to common dynamics.  It has an attribute `mem_list` which is a list of `EnsembleMember` instances, as well as `address_book` which is a list of lists of integers encoding relations between members. The element `address_book[i]` always ends with `i`. If `i` is an ancestral trajectory, `address_book[i]` has length 1. Otherwise, `address_book[i][-2]` is the parent of `i`, and so on until the leading element which is always an ancestor. `Ensemble` also has instance methods `initialize_new_member` and `run_batch` which instantiates new `EnsembleMember`s and incorporates them into the family tree. While the forward solving is achieved in `EnsembleMember.run_one_cycle`, the dynamics can be parameterized through the `model_params` argument to `Ensemble.__init__`, which is forwarded to all `EnsembleMember`s.

2. `teams_manager.py` defines an abstract class TEAMSManager which manages an instance of Ensemble to implement the TEAMS algorithm. The manager can be seen as a state machine which updates with each new trajectory, the update being performed by the method `take_next_step`. The algorithm's state is encoded through the following mutable instance variables:
    - `max_scores` (and other lists initialized in `TEAMSManager.__init__`) track the score functions, splitting times, and other information for each new member.
    - `acq_state_global` (a dictionary) holds the information for choosing members to split, members to kill, weights assigned to each member, multiplicities, and the current level.
    - `acq_state_local` (a dictionary with a different key for each member) holds the information needed to spawn a child from that member, most importantly the time at which the member's score crosses the current level.


3. `pert_manager.py` defines an abstract class `PERTManager` which manages an instance of `Ensemble` to perform the experiments to quantify divergence rates of trajectories. The structure is similar to that of `TEAMSManager` but with much simpler logic.
